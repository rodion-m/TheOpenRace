@page "/referee/distances/{distance:int}"
@using OpenRace.Data.Ef
@using System.Drawing
@using NodaTime
@using OpenRace.Data
@using OpenRace.Entities
@using OpenRace.Features.Events

@inherits OpenRace.Features.Auth.ComponentBaseWithSession
@implements IDisposable

@inject NavigationManager NavigationManager
@inject AppConfig AppConfig
@inject MembersRepository MembersRepo
@inject EventsDbRepository EventsRepo
@inject EventsSubscriptionManager EventsSubscriptionManager
@inject IToastService ToastService
@inject IClock Clock

<h1>Участники</h1>

@if (Session.IsAuthorized())
{
	if (_membersLaps != null)
	{
		var distanceColor = ColorTranslator.ToHtml(_distanceInfo.Color);
		<table style="border: 5px">
			<tr style="border: 5px">
				@foreach (var lap in _membersLaps)
				{
					var color = lap.IsCome ? distanceColor : ColorTranslator.ToHtml(Color.LightSlateGray);
					<button class="btn" @onclick="() => LapComplete(lap.MemberNumber, lap.NextLap)"
					        style="background-color: @color; width: 90px; height: 70px; margin: 5px">
						<span style="font-weight: bold; font-size: 150%">@(lap.MemberNumber)</span> <sup>⬤@(lap.NextLap)</sup>
					</button>
				}
			</tr>
		</table>
		<hr/>
		<hr/>
		<hr/>
		<hr/>
		<hr/>
		<hr/>
		<hr/>
		<hr/>
		<hr/>
		<hr/>
		<hr/>
		<hr/>
		<hr/>
		<button class="btn btn-danger" @onclick="CancelLastEvent"
		        style="width: 200px; height: 70px">
			Отменить последнее действие
		</button>
	}
	else
	{
		<div>Загрузка...</div>
	}
}
else
{
	<div>Требуется авторизация</div>
}

@code {
	[Parameter]
	public int Distance { get; set; }
	
	private List<MemberLap>? _membersLaps;
	
	private System.Threading.Timer? _timerUpdateRunners;
	private readonly Duration _minUpdateInterval = Duration.FromSeconds(1);
	private readonly Duration _timerUpdateRunnersInterval = Duration.FromSeconds(10);
	private Instant _lastUpdatedAt = Instant.MinValue;
	private bool _updating;
	private bool _disposed;

	private record MemberLap(int MemberNumber, int NextLap)
	{
		public bool IsCome { get; set; }
	}
	
	protected override async Task OnAuthorizedAsync()
	{
		await base.OnAuthorizedAsync();
		await UpdateRunners();

		SubscribeToEventsUpdate();
		CreateUpdateRunnersTimer();
		
		await RemoveBadLaps();
	}

	int _subscriptionId;
	private void SubscribeToEventsUpdate()
	{
		_subscriptionId = EventsSubscriptionManager.Subscribe(Distance, NewEventReceived);
	}

	private void NewEventReceived(RaceEvent @event)
	{
		if (!_disposed && !_busy)
		{
		}
	}

	private async Task RemoveBadLaps()
	{
		var events = await EventsRepo.GetRaceEvents(AppConfig.RaceId, Distance)
			.ToLookupAsync(it => it.MemberNumber);
		foreach (var memberEvents in events)
		{
			var raceEvents = memberEvents.Where(it => it.EventType != EventType.RaceFinished)
				.OrderBy(it => it.TimeStamp)
				.ToArray();
			for (var i = 1; i < raceEvents.Length; i++)
			{
				var prevEvent = raceEvents[i - 1];
				var e = raceEvents[i];
				var interval = e.TimeStamp - prevEvent.TimeStamp;
				if (interval < Duration.FromSeconds(60))
				{
					await EventsRepo.DeleteAsync(e);
				}
			}
		}
	}

	private void CreateUpdateRunnersTimer()
	{
		_timerUpdateRunners = new System.Threading.Timer(async _ =>
		{
			if (!_disposed && !_busy)
			{
				if (Clock.GetCurrentInstant() - _lastUpdatedAt > _minUpdateInterval)
				{
					await InvokeAsync(async () =>
					{
						ToastService.ShowInfo("Обновление...");
						await UpdateRunners();
					});
				}
			}
		}, null, _timerUpdateRunnersInterval.ToTimeSpan(), _timerUpdateRunnersInterval.ToTimeSpan());
	}

	private async Task UpdateRunners()
	{
		if (_updating)
		{
			return;
		}
		try
		{
			_updating = true;
			
			var events = await EventsRepo.GetRaceEvents(AppConfig.RaceId, Distance)
				.ToLookupAsync(it => it.MemberNumber);

			var newMembersLaps = events
				.Where(it => !it.Any(e => e.EventType == EventType.RaceFinished))
				.OrderBy(it => it.Last().TimeStamp)
				.Select(memberEvents =>
				{
					var lapCount = memberEvents.Count(it => it.EventType == EventType.LapComplete);
					return new MemberLap(memberEvents.Key, lapCount + 1);
				}).ToList();

			newMembersLaps = FilterNotComeRunners(newMembersLaps);
			
			if (!_disposed)
			{
				_lastUpdatedAt = Clock.GetCurrentInstant();
				if(_membersLaps == null || !_membersLaps.SequenceEqual(newMembersLaps))
				{
					_membersLaps = newMembersLaps;
					StateHasChanged();
				}
			}
		}
		finally
		{
			_updating = false;
		}
	}

	private static List<MemberLap> FilterNotComeRunners(List<MemberLap> members)
	{
		var maxLapsCompletedRightNow = members.Count > 0 ? members.Max(it => it.NextLap) - 1 : 0;
		bool IsCome(int lapCount)
		{
			if (lapCount > 0) return true;
			if (maxLapsCompletedRightNow < 2) return true;
			return false;
		}

		foreach (var lap in members)
		{
			lap.IsCome = IsCome(lap.NextLap - 1);
		}

		return members.OrderByDescending(it => it.IsCome).ToList();
	}

	private bool _busy;
	private AppConfig.DistanceInfo _distanceInfo => AppConfig.GetDistanceInfo(Distance);
	private async Task LapComplete(int memberNumber, int newLap)
	{
		// Заметка. Проблему с отключением кнопки можно решать на клиенте через JS: https://docs.microsoft.com/en-us/aspnet/core/blazor/javascript-interoperability/?view=aspnetcore-5.0
		if(CancelIfBusy()) return;
		try
		{
			_busy = true;
			await EventsRepo.AddAsync(new RaceEvent(
				Guid.NewGuid(), 
				AppConfig.RaceId, 
				memberNumber, 
				EventType.LapComplete, 
				Clock.GetCurrentInstant(),
				Session.UserName,
				Distance)
			);
			var remainingLaps = _distanceInfo.LapsCount - newLap;
			if (remainingLaps > 0)
			{
				ToastService.ShowInfo($"Участник {memberNumber} пошел на {newLap}-й круг");
			}
			else
			{
				await EventsRepo.AddAsync(new RaceEvent(
					Guid.NewGuid(), 
					AppConfig.RaceId, 
					memberNumber, 
					EventType.RaceFinished, 
					Clock.GetCurrentInstant(),
					Session.UserName,
					Distance)
				);
				ToastService.ShowSuccess($"Участник {memberNumber} завершил гонку!");
			}
			await UpdateRunners();
		}
		finally
		{
			_busy = false;
		}
	}

	private async Task CancelLastEvent()
	{
		if(CancelIfBusy()) return;
		try
		{
			_busy = true;
			ToastService.ShowWarning("Отмена последнего действия...");
			var @event = await EventsRepo.GetLastEventByCreatorOrNull(Session.UserName);
			if (@event != null && @event.EventType != EventType.RaceStarted)
			{
				await EventsRepo.DeleteAsync(@event);
				ToastService.ShowSuccess($"Действие {@event.EventType} отменено для участника {@event.MemberNumber}");
				if (@event.EventType == EventType.RaceFinished)
				{
					_busy = false;
					await CancelLastEvent();
				}
			}
			else
			{
				ToastService.ShowError("Нет действий");
			}
			await UpdateRunners();
		}
		finally
		{
			_busy = false;
		}
	}

	private bool CancelIfBusy()
	{
		if (_busy)
		{
			ToastService.ShowWarning("Действие уже выполняется...");
			return true;
		}
		return false;
	}

	public void Dispose()
	{
		_disposed = true;
		EventsSubscriptionManager.Unsubscribe(Distance, _subscriptionId);
		_timerUpdateRunners?.Dispose();
	}
}